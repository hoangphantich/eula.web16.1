{"version":3,"sources":["meteor://ðŸ’»app/client/plugins/flot/jquery.flot.spline.js"],"names":[],"mappings":"eAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/client/plugins/flot/jquery.flot.spline.js","sourcesContent":["/**\n * Flot plugin that provides spline interpolation for line graphs\n * author: Alex Bardas < alex.bardas@gmail.com >\n * modified by: Avi Kohn https://github.com/AMKohn\n * based on the spline interpolation described at:\n *\t\t http://scaledinnovation.com/analytics/splines/aboutSplines.html\n *\n * Example usage: (add in plot options series object)\n *\t\tfor linespline:\n *\t\t\tseries: {\n *\t\t\t\t...\n *\t\t\t\tlines: {\n *\t\t\t\t\tshow: false\n *\t\t\t\t},\n *\t\t\t\tsplines: {\n *\t\t\t\t\tshow: true,\n *\t\t\t\t\ttension: x, (float between 0 and 1, defaults to 0.5),\n *\t\t\t\t\tlineWidth: y (number, defaults to 2),\n *\t\t\t\t\tfill: z (float between 0 .. 1 or false, as in flot documentation)\n *\t\t\t\t},\n *\t\t\t\t...\n *\t\t\t}\n *\t\tareaspline:\n *\t\t\tseries: {\n *\t\t\t\t...\n *\t\t\t\tlines: {\n *\t\t\t\t\tshow: true,\n *\t\t\t\t\tlineWidth: 0, (line drawing will not execute)\n *\t\t\t\t\tfill: x, (float between 0 .. 1, as in flot documentation)\n *\t\t\t\t\t...\n *\t\t\t\t},\n *\t\t\t\tsplines: {\n *\t\t\t\t\tshow: true,\n *\t\t\t\t\ttension: 0.5 (float between 0 and 1)\n *\t\t\t\t},\n *\t\t\t\t...\n *\t\t\t}\n *\n */\n\n(function($) {\n    'use strict'\n\n    /**\n     * @param {Number} x0, y0, x1, y1: coordinates of the end (knot) points of the segment\n     * @param {Number} x2, y2: the next knot (not connected, but needed to calculate p2)\n     * @param {Number} tension: control how far the control points spread\n     * @return {Array}: p1 -> control point, from x1 back toward x0\n     * \t\t\t\t\tp2 -> the next control point, returned to become the next segment's p1\n     *\n     * @api private\n     */\n    function getControlPoints(x0, y0, x1, y1, x2, y2, tension) {\n\n        var pow = Math.pow,\n            sqrt = Math.sqrt,\n            d01, d12, fa, fb, p1x, p1y, p2x, p2y;\n\n        //  Scaling factors: distances from this knot to the previous and following knots.\n        d01 = sqrt(pow(x1 - x0, 2) + pow(y1 - y0, 2));\n        d12 = sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n\n        fa = tension * d01 / (d01 + d12);\n        fb = tension - fa;\n\n        p1x = x1 + fa * (x0 - x2);\n        p1y = y1 + fa * (y0 - y2);\n\n        p2x = x1 - fb * (x0 - x2);\n        p2y = y1 - fb * (y0 - y2);\n\n        return [p1x, p1y, p2x, p2y];\n    }\n\n    var line = [];\n\n    function drawLine(points, ctx, height, fill, seriesColor) {\n        var c = $.color.parse(seriesColor);\n\n        c.a = typeof fill == \"number\" ? fill : .3;\n        c.normalize();\n        c = c.toString();\n\n        ctx.beginPath();\n        ctx.moveTo(points[0][0], points[0][1]);\n\n        var plength = points.length;\n\n        for (var i = 0; i < plength; i++) {\n            ctx[points[i][3]].apply(ctx, points[i][2]);\n        }\n\n        ctx.stroke();\n\n        ctx.lineWidth = 0;\n        ctx.lineTo(points[plength - 1][0], height);\n        ctx.lineTo(points[0][0], height);\n\n        ctx.closePath();\n\n        if (fill !== false) {\n            ctx.fillStyle = c;\n            ctx.fill();\n        }\n    }\n\n    /**\n     * @param {Object} ctx: canvas context\n     * @param {String} type: accepted strings: 'bezier' or 'quadratic' (defaults to quadratic)\n     * @param {Array} points: 2 points for which to draw the interpolation\n     * @param {Array} cpoints: control points for those segment points\n     *\n     * @api private\n     */\n    function queue(ctx, type, points, cpoints) {\n        if (type === void 0 || (type !== 'bezier' && type !== 'quadratic')) {\n            type = 'quadratic';\n        }\n        type = type + 'CurveTo';\n\n        if (line.length == 0) line.push([points[0], points[1], cpoints.concat(points.slice(2)), type]);\n        else if (type == \"quadraticCurveTo\" && points.length == 2) {\n            cpoints = cpoints.slice(0, 2).concat(points);\n\n            line.push([points[0], points[1], cpoints, type]);\n        }\n        else line.push([points[2], points[3], cpoints.concat(points.slice(2)), type]);\n    }\n\n    /**\n     * @param {Object} plot\n     * @param {Object} ctx: canvas context\n     * @param {Object} series\n     *\n     * @api private\n     */\n\n    function drawSpline(plot, ctx, series) {\n        // Not interested if spline is not requested\n        if (series.splines.show !== true) {\n            return;\n        }\n\n        var cp = [],\n        // array of control points\n            tension = series.splines.tension || 0.5,\n            idx, x, y, points = series.datapoints.points,\n            ps = series.datapoints.pointsize,\n            plotOffset = plot.getPlotOffset(),\n            len = points.length,\n            pts = [];\n\n        line = [];\n\n        // Cannot display a linespline/areaspline if there are less than 3 points\n        if (len / ps < 4) {\n            $.extend(series.lines, series.splines);\n            return;\n        }\n\n        for (idx = 0; idx < len; idx += ps) {\n            x = points[idx];\n            y = points[idx + 1];\n            if (x == null || x < series.xaxis.min || x > series.xaxis.max || y < series.yaxis.min || y > series.yaxis.max) {\n                continue;\n            }\n\n            pts.push(series.xaxis.p2c(x) + plotOffset.left, series.yaxis.p2c(y) + plotOffset.top);\n        }\n\n        len = pts.length;\n\n        // Draw an open curve, not connected at the ends\n        for (idx = 0; idx < len - 2; idx += 2) {\n            cp = cp.concat(getControlPoints.apply(this, pts.slice(idx, idx + 6).concat([tension])));\n        }\n\n        ctx.save();\n        ctx.strokeStyle = series.color;\n        ctx.lineWidth = series.splines.lineWidth;\n\n        queue(ctx, 'quadratic', pts.slice(0, 4), cp.slice(0, 2));\n\n        for (idx = 2; idx < len - 3; idx += 2) {\n            queue(ctx, 'bezier', pts.slice(idx, idx + 4), cp.slice(2 * idx - 2, 2 * idx + 2));\n        }\n\n        queue(ctx, 'quadratic', pts.slice(len - 2, len), [cp[2 * len - 10], cp[2 * len - 9], pts[len - 4], pts[len - 3]]);\n\n        drawLine(line, ctx, plot.height() + 10, series.splines.fill, series.color);\n\n        ctx.restore();\n    }\n\n    $.plot.plugins.push({\n        init: function(plot) {\n            plot.hooks.drawSeries.push(drawSpline);\n        },\n        options: {\n            series: {\n                splines: {\n                    show: false,\n                    lineWidth: 2,\n                    tension: 0.5,\n                    fill: false\n                }\n            }\n        },\n        name: 'spline',\n        version: '0.8.2'\n    });\n})(jQuery);\n"]}